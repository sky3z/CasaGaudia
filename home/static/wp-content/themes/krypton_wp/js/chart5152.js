// @prepros-prepend "jquery.appear.js"

// Generated by CoffeeScript 1.4.0

/*
Easy pie chart is a jquery plugin to display simple animated pie charts for only one value

Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.

Built on top of the jQuery library (http://jquery.com)

@source: http://github.com/rendro/easy-pie-chart/
@autor: Robert Fleischmann
@version: 1.0.1

Inspired by: http://dribbble.com/shots/631074-Simple-Pie-Charts-II?list=popular&offset=210
Thanks to Philip Thrasher for the jquery plugin boilerplate for coffee script
*/
(function(){(function($){$.easyPieChart=function(el,options){var addScaleLine,animateLine,drawLine,easeInOutQuad,renderBackground,renderScale,renderTrack,renderCenter,_this=this;this.el=el;this.$el=$(el);this.$el.data("easyPieChart",this);this.init=function(){var percent;_this.options=$.extend({},$.easyPieChart.defaultOptions,options);percent=parseInt(_this.$el.data('percent'),10);_this.percentage=0;_this.canvas=$("<canvas width='"+_this.options.size+"' height='"+_this.options.size+"'></canvas>").get(0);_this.$el.append(_this.canvas);if(typeof G_vmlCanvasManager!=="undefined"&&G_vmlCanvasManager!==null){G_vmlCanvasManager.initElement(_this.canvas)}_this.ctx=_this.canvas.getContext('2d');if(window.devicePixelRatio>1.5){$(_this.canvas).css({width:_this.options.size,height:_this.options.size});_this.canvas.width*=2;_this.canvas.height*=2;_this.ctx.scale(2,2)}_this.ctx.translate(_this.options.size/2,_this.options.size/2);_this.$el.addClass('easyPieChart');_this.$el.css({width:_this.options.size,height:_this.options.size,lineHeight:""+_this.options.size+"px"});_this.update(percent);return _this};this.update=function(percent){if(_this.options.animate===false){return drawLine(percent)}else{return animateLine(_this.percentage,percent)}};renderScale=function(){var i,_i,_results;_this.ctx.fillStyle=_this.options.scaleColor;_this.ctx.lineWidth=1;_results=[];for(i=_i=0;_i<=24;i=++_i){_results.push(addScaleLine(i))}return _results};addScaleLine=function(i){var offset;offset=i%6===0?0:_this.options.size*0.017;_this.ctx.save();_this.ctx.rotate(i*Math.PI/12);_this.ctx.fillRect(_this.options.size/2-offset,0,-_this.options.size*0.05+offset,1);return _this.ctx.restore()};renderTrack=function(){var offset;offset=_this.options.size/2 -_this.options.lineWidth/2;if(_this.options.scaleColor!==false){offset-=_this.options.size*0.08}_this.ctx.beginPath();_this.ctx.arc(0,0,offset,0,Math.PI*2,true);_this.ctx.closePath();_this.ctx.strokeStyle=_this.options.trackColor;_this.ctx.lineWidth=_this.options.lineWidth;if(_this.options.trackWidth!=="undefined" && _this.options.trackWidth < _this.ctx.lineWidth ){_this.ctx.lineWidth=_this.options.trackWidth;}return _this.ctx.stroke()};renderBackground=function(){if(_this.options.scaleColor!==false){renderScale()}if(_this.options.trackColor!==false){return renderTrack()}};drawLine=function(percent){var offset;_this.ctx.strokeStyle=$.isFunction(_this.options.barColor)?_this.options.barColor(percent):_this.options.barColor;_this.ctx.lineCap=_this.options.lineCap;_this.ctx.lineWidth=_this.options.lineWidth;offset=_this.options.size/2-_this.options.lineWidth/2;if(_this.options.scaleColor!==false){offset-=_this.options.size*0.08}_this.ctx.save();_this.ctx.rotate(-Math.PI/2);_this.ctx.beginPath();_this.ctx.arc(0,0,offset,0,Math.PI*2*percent/100,false);_this.ctx.stroke();return _this.ctx.restore()};animateLine=function(from,to){var currentStep,fps,steps;fps=30;steps=fps*_this.options.animate/1000;	currentStep=0;_this.options.onStart.call(_this);_this.percentage=to;if(_this.animation){clearInterval(_this.animation);_this.animation=false}return _this.animation=setInterval(function(){_this.ctx.clearRect(-_this.options.size/2,-_this.options.size/2,_this.options.size,_this.options.size);renderBackground.call(_this);drawLine.call(_this,[easeInOutQuad(currentStep,from,to-from,steps)]);currentStep++;if((currentStep/steps)>1){clearInterval(_this.animation);_this.animation=false;return _this.options.onStop.call(_this)}},1000/fps)};easeInOutQuad=function(t,b,c,d){var easeIn,easing;easeIn=function(t){return Math.pow(t,2)};easing=function(t){if(t<1){return easeIn(t)}else{return 2-easeIn((t/2)*-2+2)}};t/=d/2;return c/2*easing(t)+b};return this.init()};$.easyPieChart.defaultOptions={barColor:'#ef1e25',trackColor:'#f2f2f2',scaleColor:'#dfe0e0',lineCap:'square',size:264,trackWidth:0,lineWidth:3,animate:false,onStart:$.noop,onStop:$.noop};$.fn.easyPieChart=function(options){return $.each(this,function(i,el){var $el;$el=$(el);if(!$el.data('easyPieChart')){return $el.data('easyPieChart',new $.easyPieChart(el,options))}})};return void 0})(jQuery)}).call(this);



/*!
 * Chart.js
 * http://chartjs.org/
 *
 * Copyright 2013 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */

//Define the global Chart Variable as a class.
window.Chart = function(context){

    var chart = this;
    
    
    //Easing functions adapted from Robert Penner's easing equations
    //http://www.robertpenner.com/easing/
    
    var animationOptions = {
        linear : function (t){
            return t;
        },
        easeInQuad: function (t) {
            return t*t;
        },
        easeOutQuad: function (t) {
            return -1 *t*(t-2);
        },
        easeInOutQuad: function (t) {
            if ((t/=1/2) < 1) return 1/2*t*t;
            return -1/2 * ((--t)*(t-2) - 1);
        },
        easeInCubic: function (t) {
            return t*t*t;
        },
        easeOutCubic: function (t) {
            return 1*((t=t/1-1)*t*t + 1);
        },
        easeInOutCubic: function (t) {
            if ((t/=1/2) < 1) return 1/2*t*t*t;
            return 1/2*((t-=2)*t*t + 2);
        },
        easeInQuart: function (t) {
            return t*t*t*t;
        },
        easeOutQuart: function (t) {
            return -1 * ((t=t/1-1)*t*t*t - 1);
        },
        easeInOutQuart: function (t) {
            if ((t/=1/2) < 1) return 1/2*t*t*t*t;
            return -1/2 * ((t-=2)*t*t*t - 2);
        },
        easeInQuint: function (t) {
            return 1*(t/=1)*t*t*t*t;
        },
        easeOutQuint: function (t) {
            return 1*((t=t/1-1)*t*t*t*t + 1);
        },
        easeInOutQuint: function (t) {
            if ((t/=1/2) < 1) return 1/2*t*t*t*t*t;
            return 1/2*((t-=2)*t*t*t*t + 2);
        },
        easeInSine: function (t) {
            return -1 * Math.cos(t/1 * (Math.PI/2)) + 1;
        },
        easeOutSine: function (t) {
            return 1 * Math.sin(t/1 * (Math.PI/2));
        },
        easeInOutSine: function (t) {
            return -1/2 * (Math.cos(Math.PI*t/1) - 1);
        },
        easeInExpo: function (t) {
            return (t==0) ? 1 : 1 * Math.pow(2, 10 * (t/1 - 1));
        },
        easeOutExpo: function (t) {
            return (t==1) ? 1 : 1 * (-Math.pow(2, -10 * t/1) + 1);
        },
        easeInOutExpo: function (t) {
            if (t==0) return 0;
            if (t==1) return 1;
            if ((t/=1/2) < 1) return 1/2 * Math.pow(2, 10 * (t - 1));
            return 1/2 * (-Math.pow(2, -10 * --t) + 2);
            },
        easeInCirc: function (t) {
            if (t>=1) return t;
            return -1 * (Math.sqrt(1 - (t/=1)*t) - 1);
        },
        easeOutCirc: function (t) {
            return 1 * Math.sqrt(1 - (t=t/1-1)*t);
        },
        easeInOutCirc: function (t) {
            if ((t/=1/2) < 1) return -1/2 * (Math.sqrt(1 - t*t) - 1);
            return 1/2 * (Math.sqrt(1 - (t-=2)*t) + 1);
        },
        easeInElastic: function (t) {
            var s=1.70158;var p=0;var a=1;
            if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
            if (a < Math.abs(1)) { a=1; var s=p/4; }
            else var s = p/(2*Math.PI) * Math.asin (1/a);
            return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
        },
        easeOutElastic: function (t) {
            var s=1.70158;var p=0;var a=1;
            if (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;
            if (a < Math.abs(1)) { a=1; var s=p/4; }
            else var s = p/(2*Math.PI) * Math.asin (1/a);
            return a*Math.pow(2,-10*t) * Math.sin( (t*1-s)*(2*Math.PI)/p ) + 1;
        },
        easeInOutElastic: function (t) {
            var s=1.70158;var p=0;var a=1;
            if (t==0) return 0;  if ((t/=1/2)==2) return 1;  if (!p) p=1*(.3*1.5);
            if (a < Math.abs(1)) { a=1; var s=p/4; }
            else var s = p/(2*Math.PI) * Math.asin (1/a);
            if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));
            return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p )*.5 + 1;
        },
        easeInBack: function (t) {
            var s = 1.70158;
            return 1*(t/=1)*t*((s+1)*t - s);
        },
        easeOutBack: function (t) {
            var s = 1.70158;
            return 1*((t=t/1-1)*t*((s+1)*t + s) + 1);
        },
        easeInOutBack: function (t) {
            var s = 1.70158; 
            if ((t/=1/2) < 1) return 1/2*(t*t*(((s*=(1.525))+1)*t - s));
            return 1/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
        },
        easeInBounce: function (t) {
            return 1 - animationOptions.easeOutBounce (1-t);
        },
        easeOutBounce: function (t) {
            if ((t/=1) < (1/2.75)) {
                return 1*(7.5625*t*t);
            } else if (t < (2/2.75)) {
                return 1*(7.5625*(t-=(1.5/2.75))*t + .75);
            } else if (t < (2.5/2.75)) {
                return 1*(7.5625*(t-=(2.25/2.75))*t + .9375);
            } else {
                return 1*(7.5625*(t-=(2.625/2.75))*t + .984375);
            }
        },
        easeInOutBounce: function (t) {
            if (t < 1/2) return animationOptions.easeInBounce (t*2) * .5;
            return animationOptions.easeOutBounce (t*2-1) * .5 + 1*.5;
        }
    };

    //Variables global to the chart
    var width = context.canvas.width;
    var height = context.canvas.height;


    //High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
    if (window.devicePixelRatio) {
        context.canvas.style.width = width + "px";
        context.canvas.style.height = height + "px";
        context.canvas.height = height * window.devicePixelRatio;
        context.canvas.width = width * window.devicePixelRatio;
        context.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    this.PolarArea = function(data,options){
    
        chart.PolarArea.defaults = {
            scaleOverlay : true,
            scaleOverride : false,
            scaleSteps : null,
            scaleStepWidth : null,
            scaleStartValue : null,
            scaleShowLine : true,
            scaleLineColor : "rgba(0,0,0,.1)",
            scaleLineWidth : 1,
            scaleShowLabels : true,
            scaleLabel : "<%=value%>",
            scaleFontFamily : "'Arial'",
            scaleFontSize : 12,
            scaleFontStyle : "normal",
            scaleFontColor : "#666",
            scaleShowLabelBackdrop : true,
            scaleBackdropColor : "rgba(255,255,255,0.75)",
            scaleBackdropPaddingY : 2,
            scaleBackdropPaddingX : 2,
            segmentShowStroke : true,
            segmentStrokeColor : "#fff",
            segmentStrokeWidth : 2,
            animation : true,
            animationSteps : 100,
            animationEasing : "easeOutBounce",
            animateRotate : true,
            animateScale : false,
            onAnimationComplete : null
        };
        
        var config = (options)? mergeChartConfig(chart.PolarArea.defaults,options) : chart.PolarArea.defaults;
        
        return new PolarArea(data,config,context);
    };

    this.Radar = function(data,options){
    
        chart.Radar.defaults = {
            scaleOverlay : false,
            scaleOverride : false,
            scaleSteps : null,
            scaleStepWidth : null,
            scaleStartValue : null,
            scaleShowLine : true,
            scaleLineColor : "rgba(0,0,0,.1)",
            scaleLineWidth : 1,
            scaleShowLabels : false,
            scaleLabel : "<%=value%>",
            scaleFontFamily : "'Arial'",
            scaleFontSize : 12,
            scaleFontStyle : "normal",
            scaleFontColor : "#666",
            scaleShowLabelBackdrop : true,
            scaleBackdropColor : "rgba(255,255,255,0.75)",
            scaleBackdropPaddingY : 2,
            scaleBackdropPaddingX : 2,
            angleShowLineOut : true,
            angleLineColor : "rgba(0,0,0,.1)",
            angleLineWidth : 1,         
            pointLabelFontFamily : "'Arial'",
            pointLabelFontStyle : "normal",
            pointLabelFontSize : 12,
            pointLabelFontColor : "#666",
            pointDot : true,
            pointDotRadius : 3,
            pointDotStrokeWidth : 1,
            datasetStroke : true,
            datasetStrokeWidth : 2,
            datasetFill : true,
            animation : true,
            animationSteps : 60,
            animationEasing : "easeOutQuart",
            onAnimationComplete : null
        };
        
        var config = (options)? mergeChartConfig(chart.Radar.defaults,options) : chart.Radar.defaults;

        return new Radar(data,config,context);
    };
    
    this.Pie = function(data,options){
        chart.Pie.defaults = {
            segmentShowStroke : true,
            segmentStrokeColor : "#fff",
            segmentStrokeWidth : 2,
            animation : true,
            animationSteps : 100,
            animationEasing : "easeOutBounce",
            animateRotate : true,
            animateScale : false,
            onAnimationComplete : null
        };      

        var config = (options)? mergeChartConfig(chart.Pie.defaults,options) : chart.Pie.defaults;
        
        return new Pie(data,config,context);                
    };
    
    this.Doughnut = function(data,options){
    
        chart.Doughnut.defaults = {
            segmentShowStroke : true,
            segmentStrokeColor : "#fff",
            segmentStrokeWidth : 2,
            percentageInnerCutout : 50,
            animation : true,
            animationSteps : 100,
            animationEasing : "easeOutBounce",
            animateRotate : true,
            animateScale : false,
            onAnimationComplete : null
        };      

        var config = (options)? mergeChartConfig(chart.Doughnut.defaults,options) : chart.Doughnut.defaults;
        
        return new Doughnut(data,config,context);           
        
    };

    this.Line = function(data,options){
    
        chart.Line.defaults = {
            scaleOverlay : false,
            scaleOverride : false,
            scaleSteps : null,
            scaleStepWidth : null,
            scaleStartValue : null,
            scaleLineColor : "rgba(0,0,0,.1)",
            scaleLineWidth : 1,
            scaleShowLabels : true,
            scaleLabel : "<%=value%>",
            scaleFontFamily : "'Arial'",
            scaleFontSize : 12,
            scaleFontStyle : "normal",
            scaleFontColor : "#666",
            scaleShowGridLines : true,
            scaleGridLineColor : "rgba(0,0,0,.05)",
            scaleGridLineWidth : 1,
            bezierCurve : true,
            pointDot : true,
            pointDotRadius : 4,
            pointDotStrokeWidth : 2,
            datasetStroke : true,
            datasetStrokeWidth : 2,
            datasetFill : true,
            animation : true,
            animationSteps : 60,
            animationEasing : "easeOutQuart",
            onAnimationComplete : null
        };      
        var config = (options) ? mergeChartConfig(chart.Line.defaults,options) : chart.Line.defaults;
        return new Line(data,config,context);
    }
    
    this.Bar = function(data,options){
        chart.Bar.defaults = {
            scaleOverlay : false,
            scaleOverride : false,
            scaleSteps : null,
            scaleStepWidth : null,
            scaleStartValue : null,
            scaleLineColor : "rgba(0,0,0,.1)",
            scaleLineWidth : 1,
            scaleShowLabels : true,
            scaleLabel : "<%=value%>",
            scaleFontFamily : "'Arial'",
            scaleFontSize : 12,
            scaleFontStyle : "normal",
            scaleFontColor : "#666",
            scaleShowGridLines : true,
            scaleGridLineColor : "rgba(0,0,0,.05)",
            scaleGridLineWidth : 1,
            barShowStroke : true,
            barStrokeWidth : 2,
            barValueSpacing : 5,
            barDatasetSpacing : 1,
            animation : true,
            animationSteps : 60,
            animationEasing : "easeOutQuart",
            onAnimationComplete : null
        };      
        var config = (options) ? mergeChartConfig(chart.Bar.defaults,options) : chart.Bar.defaults;
        
        return new Bar(data,config,context);        
    }
    
    var clear = function(c){
        c.clearRect(0, 0, width, height);
    };

    var PolarArea = function(data,config,ctx){
        var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;     
        
        
        calculateDrawingSizes();
        
        valueBounds = getValueBounds();

        labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;

        //Check and set the scale
        if (!config.scaleOverride){
            
            calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
        }
        else {
            calculatedScale = {
                steps : config.scaleSteps,
                stepValue : config.scaleStepWidth,
                graphMin : config.scaleStartValue,
                labels : []
            }
            populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
        }
        
        scaleHop = maxSize/(calculatedScale.steps);

        //Wrap in an animation loop wrapper
        animationLoop(config,drawScale,drawAllSegments,ctx);

        function calculateDrawingSizes(){
            maxSize = (Min([width,height])/2);
            //Remove whatever is larger - the font size or line width.
            
            maxSize -= Max([config.scaleFontSize*0.5,config.scaleLineWidth*0.5]);
            
            labelHeight = config.scaleFontSize*2;
            //If we're drawing the backdrop - add the Y padding to the label height and remove from drawing region.
            if (config.scaleShowLabelBackdrop){
                labelHeight += (2 * config.scaleBackdropPaddingY);
                maxSize -= config.scaleBackdropPaddingY*1.5;
            }
            
            scaleHeight = maxSize;
            //If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
            labelHeight = Default(labelHeight,5);
        }
        function drawScale(){
            for (var i=0; i<calculatedScale.steps; i++){
                //If the line object is there
                if (config.scaleShowLine){
                    ctx.beginPath();
                    ctx.arc(width/2, height/2, scaleHop * (i + 1), 0, (Math.PI * 2), true);
                    ctx.strokeStyle = config.scaleLineColor;
                    ctx.lineWidth = config.scaleLineWidth;
                    ctx.stroke();
                }

                if (config.scaleShowLabels){
                    ctx.textAlign = "center";
                    ctx.font = config.scaleFontStyle + " " + config.scaleFontSize + "px " + config.scaleFontFamily;
                    var label =  calculatedScale.labels[i];
                    //If the backdrop object is within the font object
                    if (config.scaleShowLabelBackdrop){
                        var textWidth = ctx.measureText(label).width;
                        ctx.fillStyle = config.scaleBackdropColor;
                        ctx.beginPath();
                        ctx.rect(
                            Math.round(width/2 - textWidth/2 - config.scaleBackdropPaddingX),     //X
                            Math.round(height/2 - (scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
                            Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
                            Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
                        );
                        ctx.fill();
                    }
                    ctx.textBaseline = "middle";
                    ctx.fillStyle = config.scaleFontColor;
                    ctx.fillText(label,width/2,height/2 - (scaleHop * (i + 1)));
                }
            }
        }
        function drawAllSegments(animationDecimal){
            var startAngle = -Math.PI/2,
            angleStep = (Math.PI*2)/data.length,
            scaleAnimation = 1,
            rotateAnimation = 1;
            if (config.animation) {
                if (config.animateScale) {
                    scaleAnimation = animationDecimal;
                }
                if (config.animateRotate){
                    rotateAnimation = animationDecimal;
                }
            }

            for (var i=0; i<data.length; i++){

                ctx.beginPath();
                ctx.arc(width/2,height/2,scaleAnimation * calculateOffset(data[i].value,calculatedScale,scaleHop),startAngle, startAngle + rotateAnimation*angleStep, false);
                ctx.lineTo(width/2,height/2);
                ctx.closePath();
                ctx.fillStyle = data[i].color;
                ctx.fill();

                if(config.segmentShowStroke){
                    ctx.strokeStyle = config.segmentStrokeColor;
                    ctx.lineWidth = config.segmentStrokeWidth;
                    ctx.stroke();
                }
                startAngle += rotateAnimation*angleStep;
            }
        }
        function getValueBounds() {
            var upperValue = Number.MIN_VALUE;
            var lowerValue = Number.MAX_VALUE;
            for (var i=0; i<data.length; i++){
                if (data[i].value > upperValue) {upperValue = data[i].value;}
                if (data[i].value < lowerValue) {lowerValue = data[i].value;}
            };

            var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
            var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
            
            return {
                maxValue : upperValue,
                minValue : lowerValue,
                maxSteps : maxSteps,
                minSteps : minSteps
            };
            

        }
    }

    var Radar = function (data,config,ctx) {
        var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString; 
            
        //If no labels are defined set to an empty array, so referencing length for looping doesn't blow up.
        if (!data.labels) data.labels = [];
        
        calculateDrawingSizes();

        var valueBounds = getValueBounds();

        labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;

        //Check and set the scale
        if (!config.scaleOverride){
            
            calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
        }
        else {
            calculatedScale = {
                steps : config.scaleSteps,
                stepValue : config.scaleStepWidth,
                graphMin : config.scaleStartValue,
                labels : []
            }
            populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
        }
        
        scaleHop = maxSize/(calculatedScale.steps);
        
        animationLoop(config,drawScale,drawAllDataPoints,ctx);
        
        //Radar specific functions.
        function drawAllDataPoints(animationDecimal){
            var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;

            ctx.save();
            //translate to the centre of the canvas.
            ctx.translate(width/2,height/2);
            
            //We accept multiple data sets for radar charts, so show loop through each set
            for (var i=0; i<data.datasets.length; i++){
                ctx.beginPath();

                ctx.moveTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)));
                for (var j=1; j<data.datasets[i].data.length; j++){
                    ctx.rotate(rotationDegree); 
                    ctx.lineTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)));
            
                }
                ctx.closePath();
                
                
                ctx.fillStyle = data.datasets[i].fillColor;
                ctx.strokeStyle = data.datasets[i].strokeColor;
                ctx.lineWidth = config.datasetStrokeWidth;
                ctx.fill();
                ctx.stroke();
                
                                
                if (config.pointDot){
                    ctx.fillStyle = data.datasets[i].pointColor;
                    ctx.strokeStyle = data.datasets[i].pointStrokeColor;
                    ctx.lineWidth = config.pointDotStrokeWidth;
                    for (var k=0; k<data.datasets[i].data.length; k++){
                        ctx.rotate(rotationDegree);
                        ctx.beginPath();
                        ctx.arc(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,2*Math.PI,false);
                        ctx.fill();
                        ctx.stroke();
                    }                   
                    
                }
                ctx.rotate(rotationDegree);
                
            }
            ctx.restore();
            
            
        }
        function drawScale(){
            var rotationDegree = (2*Math.PI)/data.datasets[0].data.length;
            ctx.save();
            ctx.translate(width / 2, height / 2);   
            
            if (config.angleShowLineOut){
                ctx.strokeStyle = config.angleLineColor;                    
                ctx.lineWidth = config.angleLineWidth;
                for (var h=0; h<data.datasets[0].data.length; h++){
                    
                    ctx.rotate(rotationDegree);
                    ctx.beginPath();
                    ctx.moveTo(0,0);
                    ctx.lineTo(0,-maxSize);
                    ctx.stroke();
                }
            }

            for (var i=0; i<calculatedScale.steps; i++){
                ctx.beginPath();
                
                if(config.scaleShowLine){
                    ctx.strokeStyle = config.scaleLineColor;
                    ctx.lineWidth = config.scaleLineWidth;
                    ctx.moveTo(0,-scaleHop * (i+1));                    
                    for (var j=0; j<data.datasets[0].data.length; j++){
                        ctx.rotate(rotationDegree);
                        ctx.lineTo(0,-scaleHop * (i+1));
                    }
                    ctx.closePath();
                    ctx.stroke();           
                            
                }
                
                if (config.scaleShowLabels){                
                    ctx.textAlign = 'center';
                    ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily; 
                    ctx.textBaseline = "middle";
                    
                    if (config.scaleShowLabelBackdrop){
                        var textWidth = ctx.measureText(calculatedScale.labels[i]).width;
                        ctx.fillStyle = config.scaleBackdropColor;
                        ctx.beginPath();
                        ctx.rect(
                            Math.round(- textWidth/2 - config.scaleBackdropPaddingX),     //X
                            Math.round((-scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y
                            Math.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width
                            Math.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height
                        );
                        ctx.fill();
                    }                       
                    ctx.fillStyle = config.scaleFontColor;
                    ctx.fillText(calculatedScale.labels[i],0,-scaleHop*(i+1));
                }

            }
            for (var k=0; k<data.labels.length; k++){               
            ctx.font = config.pointLabelFontStyle + " " + config.pointLabelFontSize+"px " + config.pointLabelFontFamily;
            ctx.fillStyle = config.pointLabelFontColor;
                var opposite = Math.sin(rotationDegree*k) * (maxSize + config.pointLabelFontSize);
                var adjacent = Math.cos(rotationDegree*k) * (maxSize + config.pointLabelFontSize);
                
                if(rotationDegree*k == Math.PI || rotationDegree*k == 0){
                    ctx.textAlign = "center";
                }
                else if(rotationDegree*k > Math.PI){
                    ctx.textAlign = "right";
                }
                else{
                    ctx.textAlign = "left";
                }
                
                ctx.textBaseline = "middle";
                
                ctx.fillText(data.labels[k],opposite,-adjacent);
                
            }
            ctx.restore();
        };
        function calculateDrawingSizes(){
            maxSize = (Min([width,height])/2);

            labelHeight = config.scaleFontSize*2;
            
            var labelLength = 0;
            for (var i=0; i<data.labels.length; i++){
                ctx.font = config.pointLabelFontStyle + " " + config.pointLabelFontSize+"px " + config.pointLabelFontFamily;
                var textMeasurement = ctx.measureText(data.labels[i]).width;
                if(textMeasurement>labelLength) labelLength = textMeasurement;
            }
            
            //Figure out whats the largest - the height of the text or the width of what's there, and minus it from the maximum usable size.
            maxSize -= Max([labelLength,((config.pointLabelFontSize/2)*1.5)]);              
            
            maxSize -= config.pointLabelFontSize;
            maxSize = CapValue(maxSize, null, 0);
            scaleHeight = maxSize;
            //If the label height is less than 5, set it to 5 so we don't have lines on top of each other.
            labelHeight = Default(labelHeight,5);
        };
        function getValueBounds() {
            var upperValue = Number.MIN_VALUE;
            var lowerValue = Number.MAX_VALUE;
            
            for (var i=0; i<data.datasets.length; i++){
                for (var j=0; j<data.datasets[i].data.length; j++){
                    if (data.datasets[i].data[j] > upperValue){upperValue = data.datasets[i].data[j]}
                    if (data.datasets[i].data[j] < lowerValue){lowerValue = data.datasets[i].data[j]}
                }
            }

            var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
            var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
            
            return {
                maxValue : upperValue,
                minValue : lowerValue,
                maxSteps : maxSteps,
                minSteps : minSteps
            };
            

        }
    }

    var Pie = function(data,config,ctx){
        var segmentTotal = 0;
        
        //In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
        var pieRadius = Min([height/2,width/2]) - 5;
        
        for (var i=0; i<data.length; i++){
            segmentTotal += data[i].value;
        }
        
        
        animationLoop(config,null,drawPieSegments,ctx);
                
        function drawPieSegments (animationDecimal){
            var cumulativeAngle = -Math.PI/2,
            scaleAnimation = 1,
            rotateAnimation = 1;
            if (config.animation) {
                if (config.animateScale) {
                    scaleAnimation = animationDecimal;
                }
                if (config.animateRotate){
                    rotateAnimation = animationDecimal;
                }
            }
            for (var i=0; i<data.length; i++){
                var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
                ctx.beginPath();
                ctx.arc(width/2,height/2,scaleAnimation * pieRadius,cumulativeAngle,cumulativeAngle + segmentAngle);
                ctx.lineTo(width/2,height/2);
                ctx.closePath();
                ctx.fillStyle = data[i].color;
                ctx.fill();
                
                if(config.segmentShowStroke){
                    ctx.lineWidth = config.segmentStrokeWidth;
                    ctx.strokeStyle = config.segmentStrokeColor;
                    ctx.stroke();
                }
                cumulativeAngle += segmentAngle;
            }           
        }       
    }

    var Doughnut = function(data,config,ctx){
        var segmentTotal = 0;
        
        //In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.
        var doughnutRadius = Min([height/2,width/2]) - 5;
        
        var cutoutRadius = doughnutRadius * (config.percentageInnerCutout/100);
        
        for (var i=0; i<data.length; i++){
            segmentTotal += data[i].value;
        }
        
        
        animationLoop(config,null,drawPieSegments,ctx);
        
        
        function drawPieSegments (animationDecimal){
            var cumulativeAngle = -Math.PI/2,
            scaleAnimation = 1,
            rotateAnimation = 1;
            if (config.animation) {
                if (config.animateScale) {
                    scaleAnimation = animationDecimal;
                }
                if (config.animateRotate){
                    rotateAnimation = animationDecimal;
                }
            }
            for (var i=0; i<data.length; i++){
                var segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));
                ctx.beginPath();
                ctx.arc(width/2,height/2,scaleAnimation * doughnutRadius,cumulativeAngle,cumulativeAngle + segmentAngle,false);
                ctx.arc(width/2,height/2,scaleAnimation * cutoutRadius,cumulativeAngle + segmentAngle,cumulativeAngle,true);
                ctx.closePath();
                ctx.fillStyle = data[i].color;
                ctx.fill();
                
                if(config.segmentShowStroke){
                    ctx.lineWidth = config.segmentStrokeWidth;
                    ctx.strokeStyle = config.segmentStrokeColor;
                    ctx.stroke();
                }
                cumulativeAngle += segmentAngle;
            }           
        }           
        
        
        
    }

    var Line = function(data,config,ctx){
        var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY, rotateLabels = 0;
            
        calculateDrawingSizes();
        
        valueBounds = getValueBounds();
        //Check and set the scale
        labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : "";
        if (!config.scaleOverride){
            calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
        }
        else {
            calculatedScale = {
                steps : config.scaleSteps,
                stepValue : config.scaleStepWidth,
                graphMin : config.scaleStartValue,
                labels : []
            }
            populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
        }

        scaleHop = Math.floor(scaleHeight/calculatedScale.steps); 
        calculateXAxisSize();
        animationLoop(config,drawScale,drawLines,ctx);      
        
        function drawLines(animPc){
            for (var i=0; i<data.datasets.length; i++){
                ctx.strokeStyle = data.datasets[i].strokeColor;
                ctx.lineWidth = config.datasetStrokeWidth;
                ctx.beginPath();
                ctx.moveTo(yAxisPosX, xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)))

                for (var j=1; j<data.datasets[i].data.length; j++){
                    if (config.bezierCurve){
                        ctx.bezierCurveTo(xPos(j-0.5),yPos(i,j-1),xPos(j-0.5),yPos(i,j),xPos(j),yPos(i,j));
                    }
                    else{
                        ctx.lineTo(xPos(j),yPos(i,j));
                    }
                }
                ctx.stroke();
                if (config.datasetFill){
                    ctx.lineTo(yAxisPosX + (valueHop*(data.datasets[i].data.length-1)),xAxisPosY);
                    ctx.lineTo(yAxisPosX,xAxisPosY);
                    ctx.closePath();
                    ctx.fillStyle = data.datasets[i].fillColor;
                    ctx.fill();
                }
                else{
                    ctx.closePath();
                }
                if(config.pointDot){
                    ctx.fillStyle = data.datasets[i].pointColor;
                    ctx.strokeStyle = data.datasets[i].pointStrokeColor;
                    ctx.lineWidth = config.pointDotStrokeWidth;
                    for (var k=0; k<data.datasets[i].data.length; k++){
                        ctx.beginPath();
                        ctx.arc(yAxisPosX + (valueHop *k),xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,0,Math.PI*2,true);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
            
            function yPos(dataSet,iteration){
                return xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));           
            }
            function xPos(iteration){
                return yAxisPosX + (valueHop * iteration);
            }
        }
        function drawScale(){
            //X axis line
            ctx.lineWidth = config.scaleLineWidth;
            ctx.strokeStyle = config.scaleLineColor;
            ctx.beginPath();
            ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
            ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
            ctx.stroke();
            
            
            if (rotateLabels > 0){
                ctx.save();
                ctx.textAlign = "right";
            }
            else{
                ctx.textAlign = "center";
            }
            ctx.fillStyle = config.scaleFontColor;
            for (var i=0; i<data.labels.length; i++){
                ctx.save();
                if (rotateLabels > 0){
                    ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
                    ctx.rotate(-(rotateLabels * (Math.PI/180)));
                    ctx.fillText(data.labels[i], 0,0);
                    ctx.restore();
                }
                
                else{
                    ctx.fillText(data.labels[i], yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize+3);                    
                }

                ctx.beginPath();
                ctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY+3);
                
                //Check i isnt 0, so we dont go over the Y axis twice.
                if(config.scaleShowGridLines && i>0){
                    ctx.lineWidth = config.scaleGridLineWidth;
                    ctx.strokeStyle = config.scaleGridLineColor;                    
                    ctx.lineTo(yAxisPosX + i * valueHop, 5);
                }
                else{
                    ctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY+3);              
                }
                ctx.stroke();
            }
            
            //Y axis
            ctx.lineWidth = config.scaleLineWidth;
            ctx.strokeStyle = config.scaleLineColor;
            ctx.beginPath();
            ctx.moveTo(yAxisPosX,xAxisPosY+5);
            ctx.lineTo(yAxisPosX,5);
            ctx.stroke();
            
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (var j=0; j<calculatedScale.steps; j++){
                ctx.beginPath();
                ctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));
                if (config.scaleShowGridLines){
                    ctx.lineWidth = config.scaleGridLineWidth;
                    ctx.strokeStyle = config.scaleGridLineColor;
                    ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));                 
                }
                else{
                    ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
                }
                
                ctx.stroke();
                
                if (config.scaleShowLabels){
                    ctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));
                }
            }
            
            
        }
        function calculateXAxisSize(){
            var longestText = 1;
            //if we are showing the labels
            if (config.scaleShowLabels){
                ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
                for (var i=0; i<calculatedScale.labels.length; i++){
                    var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
                    longestText = (measuredText > longestText)? measuredText : longestText;
                }
                //Add a little extra padding from the y axis
                longestText +=10;
            }
            xAxisLength = width - longestText - widestXLabel;
            valueHop = Math.floor(xAxisLength/(data.labels.length-1));  
                
            yAxisPosX = width-widestXLabel/2-xAxisLength;
            xAxisPosY = scaleHeight + config.scaleFontSize/2;               
        }       
        function calculateDrawingSizes(){
            maxSize = height;

            //Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
            ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
            widestXLabel = 1;
            for (var i=0; i<data.labels.length; i++){
                var textLength = ctx.measureText(data.labels[i]).width;
                //If the text length is longer - make that equal to longest text!
                widestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;
            }
            if (width/data.labels.length < widestXLabel){
                rotateLabels = 45;
                if (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){
                    rotateLabels = 90;
                    maxSize -= widestXLabel; 
                }
                else{
                    maxSize -= Math.sin(rotateLabels) * widestXLabel;
                }
            }
            else{
                maxSize -= config.scaleFontSize;
            }
            
            //Add a little padding between the x line and the text
            maxSize -= 5;
            
            
            labelHeight = config.scaleFontSize;
            
            maxSize -= labelHeight;
            //Set 5 pixels greater than the font size to allow for a little padding from the X axis.
            
            scaleHeight = maxSize;
            
            //Then get the area above we can safely draw on.
            
        }       
        function getValueBounds() {
            var upperValue = Number.MIN_VALUE;
            var lowerValue = Number.MAX_VALUE;
            var newValue = Number.MIN_VALUE;
            for (var i=0; i<data.datasets.length; i++){
                for (var j=0; j<data.datasets[i].data.length; j++){
                    newValue = Number(data.datasets[i].data[j]);
                    //newValue = data.datasets[i].data[j];
                    //alert('upperValue= ' + upperValue + ' j= ' + data.datasets[i].data[j]);
                    if ( newValue > upperValue) { 
                        upperValue = data.datasets[i].data[j]; 
                    };
                    if ( newValue < lowerValue) { lowerValue = data.datasets[i].data[j] };
                }
            };
            //alert('upperValue= ' + upperValue);
    
            var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
            var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
            
            return {
                maxValue : upperValue,
                minValue : lowerValue,
                maxSteps : maxSteps,
                minSteps : minSteps
            };
            
    
        }

        
    }
    
    var Bar = function(data,config,ctx){
        var maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY,barWidth, rotateLabels = 0;
            
        calculateDrawingSizes();
        
        valueBounds = getValueBounds();
        //Check and set the scale
        labelTemplateString = (config.scaleShowLabels)? config.scaleLabel : "";
        if (!config.scaleOverride){
            
            calculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);
        }
        else {
            calculatedScale = {
                steps : config.scaleSteps,
                stepValue : config.scaleStepWidth,
                graphMin : config.scaleStartValue,
                labels : []
            }
            populateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);
        }
        
        scaleHop = Math.floor(scaleHeight/calculatedScale.steps);
        calculateXAxisSize();
        animationLoop(config,drawScale,drawBars,ctx);       
        
        function drawBars(animPc){
            ctx.lineWidth = config.barStrokeWidth;
            for (var i=0; i<data.datasets.length; i++){
                    ctx.fillStyle = data.datasets[i].fillColor;
                    ctx.strokeStyle = data.datasets[i].strokeColor;
                for (var j=0; j<data.datasets[i].data.length; j++){
                    var barOffset = yAxisPosX + config.barValueSpacing + valueHop*j + barWidth*i + config.barDatasetSpacing*i + config.barStrokeWidth*i;
                    
                    ctx.beginPath();
                    ctx.moveTo(barOffset, xAxisPosY);
                    ctx.lineTo(barOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
                    ctx.lineTo(barOffset + barWidth, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));
                    ctx.lineTo(barOffset + barWidth, xAxisPosY);
                    if(config.barShowStroke){
                        ctx.stroke();
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
        }
        function drawScale(){
            //X axis line
            ctx.lineWidth = config.scaleLineWidth;
            ctx.strokeStyle = config.scaleLineColor;
            ctx.beginPath();
            ctx.moveTo(width-widestXLabel/2+5,xAxisPosY);
            ctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);
            ctx.stroke();
            
            
            if (rotateLabels > 0){
                ctx.save();
                ctx.textAlign = "right";
            }
            else{
                ctx.textAlign = "center";
            }
            ctx.fillStyle = config.scaleFontColor;
            for (var i=0; i<data.labels.length; i++){
                ctx.save();
                if (rotateLabels > 0){
                    ctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);
                    ctx.rotate(-(rotateLabels * (Math.PI/180)));
                    ctx.fillText(data.labels[i], 0,0);
                    ctx.restore();
                }
                
                else{
                    ctx.fillText(data.labels[i], yAxisPosX + i*valueHop + valueHop/2,xAxisPosY + config.scaleFontSize+3);                   
                }

                ctx.beginPath();
                ctx.moveTo(yAxisPosX + (i+1) * valueHop, xAxisPosY+3);
                
                //Check i isnt 0, so we dont go over the Y axis twice.
                    ctx.lineWidth = config.scaleGridLineWidth;
                    ctx.strokeStyle = config.scaleGridLineColor;                    
                    ctx.lineTo(yAxisPosX + (i+1) * valueHop, 5);
                ctx.stroke();
            }
            
            //Y axis
            ctx.lineWidth = config.scaleLineWidth;
            ctx.strokeStyle = config.scaleLineColor;
            ctx.beginPath();
            ctx.moveTo(yAxisPosX,xAxisPosY+5);
            ctx.lineTo(yAxisPosX,5);
            ctx.stroke();
            
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (var j=0; j<calculatedScale.steps; j++){
                ctx.beginPath();
                ctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));
                if (config.scaleShowGridLines){
                    ctx.lineWidth = config.scaleGridLineWidth;
                    ctx.strokeStyle = config.scaleGridLineColor;
                    ctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));                 
                }
                else{
                    ctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));
                }
                
                ctx.stroke();
                if (config.scaleShowLabels){
                    ctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));
                }
            }
            
            
        }
        function calculateXAxisSize(){
            var longestText = 1;
            //if we are showing the labels
            if (config.scaleShowLabels){
                ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
                for (var i=0; i<calculatedScale.labels.length; i++){
                    var measuredText = ctx.measureText(calculatedScale.labels[i]).width;
                    longestText = (measuredText > longestText)? measuredText : longestText;
                }
                //Add a little extra padding from the y axis
                longestText +=10;
            }
            xAxisLength = width - longestText - widestXLabel;
            valueHop = Math.floor(xAxisLength/(data.labels.length));    
            
            barWidth = (valueHop - config.scaleGridLineWidth*2 - (config.barValueSpacing*2) - (config.barDatasetSpacing*data.datasets.length-1) - ((config.barStrokeWidth/2)*data.datasets.length-1))/data.datasets.length;
            
            yAxisPosX = width-widestXLabel/2-xAxisLength;
            xAxisPosY = scaleHeight + config.scaleFontSize/2;               
        }       
        function calculateDrawingSizes(){
            maxSize = height;

            //Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.
            ctx.font = config.scaleFontStyle + " " + config.scaleFontSize+"px " + config.scaleFontFamily;
            widestXLabel = 1;
            for (var i=0; i<data.labels.length; i++){
                var textLength = ctx.measureText(data.labels[i]).width;
                //If the text length is longer - make that equal to longest text!
                widestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;
            }
            if (width/data.labels.length < widestXLabel){
                rotateLabels = 45;
                if (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){
                    rotateLabels = 90;
                    maxSize -= widestXLabel; 
                }
                else{
                    maxSize -= Math.sin(rotateLabels) * widestXLabel;
                }
            }
            else{
                maxSize -= config.scaleFontSize;
            }
            
            //Add a little padding between the x line and the text
            maxSize -= 5;
            
            
            labelHeight = config.scaleFontSize;
            
            maxSize -= labelHeight;
            //Set 5 pixels greater than the font size to allow for a little padding from the X axis.
            
            scaleHeight = maxSize;
            
            //Then get the area above we can safely draw on.
            
        }       
        function getValueBounds() {
            var upperValue = Number.MIN_VALUE;
            var lowerValue = Number.MAX_VALUE;
            for (var i=0; i<data.datasets.length; i++){
                for (var j=0; j<data.datasets[i].data.length; j++){
                    if ( data.datasets[i].data[j] > upperValue) { upperValue = data.datasets[i].data[j] };
                    if ( data.datasets[i].data[j] < lowerValue) { lowerValue = data.datasets[i].data[j] };
                }
            };
    
            var maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));
            var minSteps = Math.floor((scaleHeight / labelHeight*0.5));
            
            return {
                maxValue : upperValue,
                minValue : lowerValue,
                maxSteps : maxSteps,
                minSteps : minSteps
            };
            
    
        }
    }
    
    function calculateOffset(val,calculatedScale,scaleHop){
        var outerValue = calculatedScale.steps * calculatedScale.stepValue;
        var adjustedValue = val - calculatedScale.graphMin;
        var scalingFactor = CapValue(adjustedValue/outerValue,1,0);
        return (scaleHop*calculatedScale.steps) * scalingFactor;
    }
    
    function animationLoop(config,drawScale,drawData,ctx){
        var animFrameAmount = (config.animation)? 1/CapValue(config.animationSteps,Number.MAX_VALUE,1) : 1,
            easingFunction = animationOptions[config.animationEasing],
            percentAnimComplete =(config.animation)? 0 : 1;
        
    
        
        if (typeof drawScale !== "function") drawScale = function(){};
        
        requestAnimFrame(animLoop);
        
        function animateFrame(){
            var easeAdjustedAnimationPercent =(config.animation)? CapValue(easingFunction(percentAnimComplete),null,0) : 1;
            clear(ctx);
            if(config.scaleOverlay){
                drawData(easeAdjustedAnimationPercent);
                drawScale();
            } else {
                drawScale();
                drawData(easeAdjustedAnimationPercent);
            }               
        }
        function animLoop(){
            //We need to check if the animation is incomplete (less than 1), or complete (1).
                percentAnimComplete += animFrameAmount;
                animateFrame(); 
                //Stop the loop continuing forever
                if (percentAnimComplete <= 1){
                    requestAnimFrame(animLoop);
                }
                else{
                    if (typeof config.onAnimationComplete == "function") config.onAnimationComplete();
                }
            
        }       
        
    }

    //Declare global functions to be called within this namespace here.
    
    
    // shim layer with setTimeout fallback
    var requestAnimFrame = (function(){
        return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();

    function calculateScale(drawingHeight,maxSteps,minSteps,maxValue,minValue,labelTemplateString){
            var graphMin,graphMax,graphRange,stepValue,numberOfSteps,valueRange,rangeOrderOfMagnitude,decimalNum;
            
            valueRange = maxValue - minValue;
            
            rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange);

            graphMin = Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
            
            graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);
            
            graphRange = graphMax - graphMin;
            
            stepValue = Math.pow(10, rangeOrderOfMagnitude);
            
            numberOfSteps = Math.round(graphRange / stepValue);
            
            //Compare number of steps to the max and min for that size graph, and add in half steps if need be.         
            while(numberOfSteps < minSteps || numberOfSteps > maxSteps) {
                if (numberOfSteps < minSteps){
                    stepValue /= 2;
                    numberOfSteps = Math.round(graphRange/stepValue);
                }
                else{
                    stepValue *=2;
                    numberOfSteps = Math.round(graphRange/stepValue);
                }
            };

            var labels = [];
            populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue);
        
            return {
                steps : numberOfSteps,
                stepValue : stepValue,
                graphMin : graphMin,
                labels : labels             
                
            }
        
            function calculateOrderOfMagnitude(val){
              return Math.floor(Math.log(val) / Math.LN10);
            }       


    }

    //Populate an array of all the labels by interpolating the string.
    function populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue) {
        if (labelTemplateString) {
            //Fix floating point errors by setting to fixed the on the same decimal as the stepValue.
            for (var i = 1; i < numberOfSteps + 1; i++) {
                labels.push(tmpl(labelTemplateString, {value: (graphMin + (stepValue * i)).toFixed(getDecimalPlaces(stepValue))}));
            }
        }
    }
    
    //Max value from array
    function Max( array ){
        return Math.max.apply( Math, array );
    };
    //Min value from array
    function Min( array ){
        return Math.min.apply( Math, array );
    };
    //Default if undefined
    function Default(userDeclared,valueIfFalse){
        if(!userDeclared){
            return valueIfFalse;
        } else {
            return userDeclared;
        }
    };
    //Is a number function
    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    //Apply cap a value at a high or low number
    function CapValue(valueToCap, maxValue, minValue){
        if(isNumber(maxValue)) {
            if( valueToCap > maxValue ) {
                return maxValue;
            }
        }
        if(isNumber(minValue)){
            if ( valueToCap < minValue ){
                return minValue;
            }
        }
        return valueToCap;
    }
    function getDecimalPlaces (num){
        var numberOfDecimalPlaces;
        if (num%1!=0){
            return num.toString().split(".")[1].length
        }
        else{
            return 0;
        }
        
    } 
    
    function mergeChartConfig(defaults,userDefined){
        var returnObj = {};
        for (var attrname in defaults) { returnObj[attrname] = defaults[attrname]; }
        for (var attrname in userDefined) { returnObj[attrname] = userDefined[attrname]; }
        return returnObj;
    }
    
    //Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
      var cache = {};
     
      function tmpl(str, data){
        // Figure out if we're getting a template, or if we need to
        // load the template - and be sure to cache the result.
        var fn = !/\W/.test(str) ?
          cache[str] = cache[str] ||
            tmpl(document.getElementById(str).innerHTML) :
         
          // Generate a reusable function that will serve as a template
          // generator (and which will be cached).
          new Function("obj",
            "var p=[],print=function(){p.push.apply(p,arguments);};" +
           
            // Introduce the data as local variables using with(){}
            "with(obj){p.push('" +
           
            // Convert the template into pure JavaScript
            str
              .replace(/[\r\t\n]/g, " ")
              .split("<%").join("\t")
              .replace(/((^|%>)[^\t]*)'/g, "$1\r")
              .replace(/\t=(.*?)%>/g, "',$1,'")
              .split("\t").join("');")
              .split("%>").join("p.push('")
              .split("\r").join("\\'")
          + "');}return p.join('');");
       
        // Provide some basic currying to the user
        return data ? fn( data ) : fn;
      };
}

/**************************************************************/

var $j = jQuery.noConflict(),
    scroll = 0;
$j(document).ready(function () {
    "use strict";

      initDoughnutProgressBar2();
      initProgressBars();
      initPieCharts();
      initLineCharts();
});

function initCounter() {
    "use strict";
    if ($j('.counter.type2').length) {
        $j('.counter.type2').each(function () {
            $j(this).appear(function () {
                $j(this).parent().css('opacity', '1');
                $j(this).absoluteCounter({
                    speed: 2000,
                    fadeInDelay: 1000
                })
            }, {
                accX: 0,
                accY: -200
            })
        })
    }
}(function ($) {
    "use strict";
    $.fn.countTo = function (options) {
        options = $.extend({}, $.fn.countTo.defaults, options || {});
        var loops = Math.ceil(options.speed / options.refreshInterval),
            increment = (options.to - options.from) / loops;
        return $(this).each(function () {
            var _this = this,
                loopCount = 0,
                value = options.from,
                interval = setInterval(updateTimer, options.refreshInterval);

            function updateTimer() {
                value += increment;
                loopCount++;
                $(_this).html(value.toFixed(options.decimals));
                if (typeof (options.onUpdate) === 'function') {
                    options.onUpdate.call(_this, value)
                }
                if (loopCount >= loops) {
                    clearInterval(interval);
                    value = options.to;
                    if (typeof (options.onComplete) === 'function') {
                        options.onComplete.call(_this, value)
                    }
                }
            }
        })
    };
    $.fn.countTo.defaults = {
        from: 0,
        to: 100,
        speed: 1000,
        refreshInterval: 100,
        decimals: 0,
        onUpdate: null,
        onComplete: null,
    }
})(jQuery);

function initToCounter() {
    "use strict";
    if ($j('.counter.type1').length) {
        $j('.counter.type1').each(function () {
            $j(this).appear(function () {
                $j(this).parent().css('opacity', '1');
                var $max = parseFloat($j(this).text());
                $j(this).countTo({
                    from: 0,
                    to: $max,
                    speed: 1500,
                    refreshInterval: 50
                })
            }, {
                accX: 0,
                accY: -200
            })
        })
    }
}

function initDoughnutProgressBar() {
    "use strict";
    if ($j('.normal .percentage').length) {
        $j('.normal .percentage').each(function () {
            $j(this).appear(function () {
                //alert($j('.normal .percentage').parent().css("width").replace("px",""));
                var $barColor = '#69b200',
                    $trackColor = '#ededed',
                    $line_width = 10,
                    $size = 133,
                    $linecap = 'square',
                    $track_width = 10;
                if ($j(this).data('active') !== "") {
                    $barColor = $j(this).data('active')
                }
                if ($j(this).data('noactive') !== "") {
                    $trackColor = $j(this).data('noactive')
                }
                if ($j(this).data('linecap') !== "") {
                    $linecap = $j(this).data('linecap')
                }
                if ($j(this).data('linewidth') !== "") {
                    $line_width = $j(this).data('linewidth')
                }
                if ($j(this).data('trackwidth') !== "") {
                    $track_width = $j(this).data('trackwidth')
                }
                if ($j(this).data('radius') !== "") {
                    $size = $j(this).data('radius')
                }
            
                $j('.tocounter').css("line-height",$j('.normal .percentage').css("height"));
                $j('.tocounter').css("margin-top",0-$j('.normal .percentage').css("height").replace("px","")-0.5*$j('.tocounter').css("font-size").replace("px",""));

                initToCounterPicChart($j(this));
                $j(this).parent().css('opacity', '1');
                var $size = 0.85 * $j('.normal .percentage').parent().parent().css("width").replace("px","");
                
                $j(this).easyPieChart({
                    barColor: $barColor,
                    trackColor: $trackColor,
                    scaleColor: false,
                    lineCap: $linecap,
                    lineWidth: $line_width,
                    trackWidth: $track_width,
                    animate: 1500,
                    size: $size 
                })
            }, {
                accX: 0,
                accY: -100
            })
        })
    }
}

function initLineCharts() {
    "use strict";
    if ($j('.lineChart').length) {
        $j('.lineChart').each(function () {
            
            $j(this).appear(function () {
                //Get context with jQuery - using jQuery's .get() method.

                $(this).get(0).width = $(this).parent().css("width").replace("px","");
                $(this).get(0).height = 0.6 * $(this).parent().css("width").replace("px","");
   
                var ctx = $(this).get(0).getContext("2d"),$strokeColor='1ABC9C',$strokeSize=6,$source=[],$labels=[],$showLabel=false,$lblcolor='#a4a8a9',
                $lblfsize=18;

                if ($j(this).data('color')) {
                    $strokeColor = $j(this).data('color');
                }

                if ($j(this).data('size')) {
                    $strokeSize = $j(this).data('size');
                }

                if ($j(this).data('source')) {
                    $source = $j(this).data('source').split(',');
                }

                if ($j(this).data('label')) {
                    $labels = $j(this).data('label').split('||');
                }

                if ($j(this).data('showlabel')) {
                    $showLabel = $j(this).data('showlabel');
                }

                if ($j(this).data('lblcolor')) {
                    $lblcolor = $j(this).data('lblcolor');
                }

                if ($j(this).data('lblfsize')) {
                    $lblfsize = $j(this).data('lblfsize');
                }

                var data = {
                    labels : $labels,
                    datasets : [
                        {
                            fillColor : "rgba(151,187,205,0)",
                            strokeColor : $strokeColor,
                            pointColor : "rgba(151,187,205,0)",
                            pointStrokeColor : "rgba(255,255,255,0)",
                            data : $source
                        }
                    ]
                }

                var $animation = true;
                if ($(window).width()<=480) {
                    $animation = false;
                }
                //alert($(document).width());

                var options = {
                    //Boolean - If we show the scale above the chart data           
                    scaleOverlay : true,
                    //Boolean - If we want to override with a hard coded scale
                    scaleOverride : false,
                    //** Required if scaleOverride is true **
                    //Number - The number of steps in a hard coded scale
                    scaleSteps : 10,
                    //Number - The value jump in the hard coded scale
                    scaleStepWidth : 1,
                    //Number - The scale starting value
                    scaleStartValue : null,
                    //String - Colour of the scale line 
                    scaleLineColor : "rgba(0,0,0,.1)",
                    //Number - Pixel width of the scale line    
                    scaleLineWidth : 1,
                    //Boolean - Whether to show labels on the scale 
                    scaleShowLabels : $showLabel,
                    //Interpolated JS string - can access value
                    scaleLabel : "<%=value%>",
                    //String - Scale label font declaration for the scale label
                    scaleFontFamily : "'Open Sans'",
                    //Number - Scale label font size in pixels  
                    scaleFontSize : $lblfsize,
                    //String - Scale label font weight style    
                    scaleFontStyle : "normal",
                    //String - Scale label font colour  
                    scaleFontColor : $lblcolor, 
                    ///Boolean - Whether grid lines are shown across the chart
                    scaleShowGridLines : true,
                    //String - Colour of the grid lines
                    scaleGridLineColor : "rgba(0,0,0,.05)",
                    //Number - Width of the grid lines
                    scaleGridLineWidth : 1, 
                    //Boolean - Whether the line is curved between points
                    bezierCurve : false,
                    //Boolean - Whether to show a dot for each point
                    pointDot : true,
                    //Number - Radius of each point dot in pixels
                    pointDotRadius : 3,
                    //Number - Pixel width of point dot stroke
                    pointDotStrokeWidth : 1,
                    //Boolean - Whether to show a stroke for datasets
                    datasetStroke : true,
                    //Number - Pixel width of dataset stroke
                    datasetStrokeWidth : $strokeSize,
                    //Boolean - Whether to fill the dataset with a colour
                    datasetFill : true,
                    //Boolean - Whether to animate the chart
                    animation : $animation,
                    //Number - Number of animation steps
                    animationSteps : 180,
                    //String - Animation easing effect
                    animationEasing : "easeOutQuart",
                    //Function - Fires when the animation is complete
                    onAnimationComplete : null
                }
                
                //This will get the first returned node in the jQuery collection.
                var myNewChart = new Chart(ctx).Line(data,options);
            }, {
                accX: 0,
                accY: -100
            })
        })
    }
}

function initDoughnutProgressBar2() {
    "use strict";
    if ($j('.doughnutChart').length) {
        $j('.doughnutChart').each(function () {
            $j(this).appear(function () {
                //Get context with jQuery - using jQuery's .get() method.
                $j(this).get(0).width = $j(this).parent().css("width").replace("px","");
                $j(this).get(0).height = $j(this).get(0).width;

                $j(this).siblings(".pie_chart_text").find(".tocounter").css({"line-height":$j(this).get(0).height+'px','font-size':($j(this).get(0).height/4)+'px'});

                var $height = 1.2*$j(this).get(0).height;
                $j(this).parent().css("height",$height+"px");

                var sclr=$j(this).data('active'),activeStrokeColor="#19bd9b",nsclr=$j(this).data('noactive'),nonactiveStrokeColor="transparent";

                if(sclr) {activeStrokeColor=sclr;}
                if(nsclr) {nonactiveStrokeColor=nsclr;}

                var ctx = $j(this).get(0).getContext("2d");

                var data = [
                    {
                        value: $j(this).data('percent'),
                        color:activeStrokeColor
                    },
                    {
                        value : 100 - $j(this).data('percent'),
                        color : nonactiveStrokeColor
                    }
                ]

                var $animation = true;
                if ($(window).width()<=480) {
                    $animation = false;
                }

                var options = {
                    //Boolean - Whether we should show a stroke on each segment
                    segmentShowStroke : false,
                    
                    //String - The colour of each segment stroke
                    segmentStrokeColor : "transparent",
                    
                    //Number - The width of each segment stroke
                    segmentStrokeWidth : 2,
                    
                    //The percentage of the chart that we cut out of the middle.
                    percentageInnerCutout : 87,
                    
                    //Boolean - Whether we should animate the chart 
                    animation : $animation,
                    
                    //Number - Amount of animation steps
                    animationSteps : 100,
                    
                    //String - Animation easing effect
                    //animationEasing : "easeOutCubic",
                    //animationEasing : "easeOutBounce",
                    animationEasing : "easeOutCubic",

                    //Boolean - Whether we animate the rotation of the Doughnut
                    animateRotate : true,

                    //Boolean - Whether we animate scaling the Doughnut from the centre
                    animateScale : false,
                    
                    //Function - Will fire on animation completion.
                    onAnimationComplete : null                
                }

                //initToCounterPicChart($j(this).siblings(".pie_chart_text"));
                if ($animation) {
                    initToCounterInt($j(this).siblings(".pie_chart_text"),$j(this).data('percent'));
                }
                
                //This will get the first returned node in the jQuery collection.
                var myNewChart = new Chart(ctx).Doughnut(data,options);
            }, {
                accX: 0,
                accY: -100
            })
        })
    }

}

function initToCounterInt($this,$to) {
    "use strict";
    $j($this).css('opacity', '1');
    $j($this).find('.tocounter').countTo({
        from: 0,
        to: $to,
        speed: 1500,
        refreshInterval: 50
    })
}

function initToCounterPicChart($this) {
    "use strict";
    $j($this).css('opacity', '1');
    var $max = parseFloat($j($this).find('.tocounter').text());
    $j($this).find('.tocounter').countTo({
        from: 0,
        to: $max,
        speed: 1500,
        refreshInterval: 50
    })
}

function initToCounterPicChartTransparent($this) {
    "use strict";
    $j($this).css('opacity', '1');
    var $max = parseFloat($j($this).find('.tocounter').text());
    $j($this).find('.tocounter').countTo({
        from: 0,
        to: $max,
        speed: 1500,
        refreshInterval: 50
    })
}

function initProgressBars() {
    "use strict";
    if ($j('.progress_bars .progress_bar').length) {
        $j('.progress_bars .progress_bar').each(function () {
            $j(this).appear(function () {
                var $animation = true;
                if ($(window).width()<=480) {
                    $animation = false;
                }

                    var percentage = $j(this).find('.progress_content').data('percentage'),
                    percent_width = $j(this).find('.progress_number').width(),color='#1abc9c',bgcolor='transparent';
                    
                    if($j(this).find('.progress_content').data('active')){
                        color=$j(this).find('.progress_content').data('active');
                    }

                    if($j(this).find('.progress_content').data('nonactive')){
                        bgcolor=$j(this).find('.progress_content').data('nonactive');
                    }


                    $j(this).find('.progress_content_outer').css({'background-color': bgcolor});


                    if ($animation) {
                        $j(this).find('.progress_content').css({'width':'0%','background-color': color});

                        var $counter=$j(this).find('.progress_number span'),$max = parseFloat($counter.text());

                        $j(this).find('.progress_number').css('opacity', '1');

                        $counter.text(0);

                        $counter.countTo({
                            from: 0,
                            to: $max,
                            speed: 1500,
                            refreshInterval: 50
                        });

                        $j(this).find('.progress_content').animate({
                            'width': percentage + '%'
                        }, 2000,function(){

                        });
                    } else {
                        $j(this).find('.progress_content').css('width', percentage + '%');
                        $j(this).find('.progress_number').css('opacity', '1');
                    }

            }, {
                accX: 0,
                accY: -100
            })
        })
    }
}

function initPieCharts() {
    "use strict";
    if ($j('.chart').length) {
        $j('.chart').each(function () {
            $j(this).appear(function () {
                var type = $j(this).data('type'),
                    anima = $j(this).data('animation'),
                    src = $j(this).data('source'),
                    myArray = [],
                    option = [],
                    sclr = $j(this).data('segmencolor'),
                    swidth = $j(this).data('segmenwidth'),
                    iner = $j(this).data('iner');
                var piedata = src.split(',');
                for (var i = 0; i < piedata.length; i++) {
                    var a = piedata[i].split(':');
                    myArray[i] = {
                        value: parseInt(a[0]),
                        color: a[1]
                    };
                }
                if (anima) {
                    option['animationEasing'] = anima;
                }
                if (sclr) {
                    option['segmentStrokeColor'] = sclr;
                }
                if (swidth) {
                    option['segmentStrokeWidth'] = swidth;
                }
                if (iner) {
                    option['percentageInnerCutout'] = iner;
                }
                if (type == 'doughnut') {
                    new Chart($j(this)[0].getContext('2d')).Doughnut(myArray, option);
                } else {
                    new Chart($j(this)[0].getContext('2d')).Pie(myArray, option);
                }
            }, {
                accX: 0,
                accY: -200
            })
        })
    }
}

function initToCounterHorizontalProgressBar() {
    "use strict";
    if ($j('.progress_bars .progress_number span').length) {
        $j('.progress_bars .progress_number span').each(function () {
            $j(this).parent().css('opacity', '1');
            var $max = parseFloat($j(this).text());
            $j(this).countTo({
                from: 0,
                to: $max,
                speed: 1500,
                refreshInterval: 50
            })
        })
    }
}

function totop_button(a) {
    "use strict";
    var b = $j("#back_to_top");
    b.removeClass("off on");
    if (a === "on") {
        b.addClass("on")
    } else {
        b.addClass("off")
    }
}

function initProgressBarsVertical() {
    "use strict";
    if ($j('.progress_bars_vertical_holder').length) {
        $j('.progress_bars_vertical_holder').each(function () {
            var progress_bar_number = 0;
            $j(this).find('.progress_bars_vertical').each(function () {
                progress_bar_number++
            });
            $j(this).find('.progress_bars_vertical').css('width', 100 / progress_bar_number - 0.3 + '%');
            $j(this).appear(function () {
                initToCounterVerticalProgressBar();
                $j(this).find('.progress_bars_vertical').each(function () {
                    var percentage = $j(this).find('.progress_content').data('percentage');
                    $j(this).find('.progress_content').css('height', '0%');
                    $j(this).find('.progress_content').animate({
                        height: percentage + '%'
                    }, 1500)
                })
            }, {
                accX: 0,
                accY: -200
            })
        })
    }
}

function initToCounterVerticalProgressBar() {
    "use strict";
    if ($j('.progress_bars_vertical .progress_number span').length) {
        $j('.progress_bars_vertical .progress_number span').each(function () {
            var $max = parseFloat($j(this).text());
            $j(this).countTo({
                from: 0,
                to: $max,
                speed: 1500,
                refreshInterval: 50
            })
        })
    }
}
var $ = jQuery.noConflict();



$(window).smartresize(function(){
    "use strict";
    initLineCharts();
    initDoughnutProgressBar2();
});


